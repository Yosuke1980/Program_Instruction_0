# 番組別詳細表 - 関数動作まとめ

## 概要

番組別詳細表は、選択した番組の詳細データを表形式で表示する機能です。Webアプリケーション上のタブ形式のUIを通じて、ユーザーが番組を選択すると、その番組の週別エピソード詳細情報を転置テーブル形式で表示します。

この機能は以下の特徴を持ちます：
- 転置テーブル形式での表示（項目が縦、日付が横）
- 各番組に特化した項目表示
- デバッグログ機能付き
- エラーハンドリング

## 主要関数の概要

### フロントエンド関数（index.html）

| 関数名 | 場所 | 役割 |
|--------|------|------|
| `loadSingleProgramTable()` | index.html:2360 | メイン呼び出し関数 |
| `loadTransposedProgramTable()` | index.html:2365 | 転置テーブル読み込み処理 |
| `generateEpisodeDetailsHTML()` | index.html:2568 | エピソード詳細HTML生成 |
| `toggleEpisodeDetails()` | index.html:2606 | 詳細表示の切り替え |

### バックエンド関数（src/99_main.ts）

| 関数名 | 場所 | 役割 |
|--------|------|------|
| `generateTransposeTable()` | src/99_main.ts:8871 | 転置テーブルデータ生成（メイン） |
| `displayEpisodeDetailsTable()` | src/99_main.ts:7149 | コンソール用表形式表示 |
| `generateTransposedTableData()` | src/99_main.ts:9019 | 転置テーブル用データ構造生成 |
| `extractProgramData()` | src/99_main.ts:9141 | 番組の曜日別データ抽出 |
| `convertToTransposedTable()` | src/99_main.ts:9171 | 転置テーブルHTML生成 |

## データフロー

```
1. ユーザー操作（番組選択）
   ↓
2. loadSingleProgramTable() [index.html:2360]
   ↓
3. loadTransposedProgramTable() [index.html:2365]
   ↓
4. Google Apps Scriptへのリクエスト
   ↓
5. generateTransposeTable() [src/99_main.ts:8871]
   ↓
6. extractWeekByNumber() → extractProgramData() [src/99_main.ts:9141]
   ↓
7. generateTransposedTableData() [src/99_main.ts:9019]
   ↓
8. HTMLテーブル表示
```

## 各関数の詳細動作

### 1. loadSingleProgramTable()
**場所**: index.html:2360  
**概要**: 番組詳細データ表示のメイン関数  

```javascript
function loadSingleProgramTable() {
    loadTransposedProgramTable(); // 転置テーブルを直接呼び出し
}
```

**動作**:
- 実際の処理は`loadTransposedProgramTable()`に委譲
- UIボタンから呼び出される

### 2. loadTransposedProgramTable()
**場所**: index.html:2365  
**概要**: 転置テーブル形式の番組詳細表を読み込む  

**動作**:
1. 番組選択とウィーク選択の値を取得
2. 選択値の厳密な検証（空文字、undefined チェック）
3. Google Apps Script の `generateTransposeTable` を呼び出し
4. 成功時：受信データでHTMLテーブルを生成・表示
5. エラー時：エラーメッセージを表示
6. デバッグログを常に表示

**エラーハンドリング**:
- 番組未選択時のエラー表示
- API呼び出し失敗時のエラー表示
- デバッグログによる詳細情報提供

### 3. generateEpisodeDetailsHTML()
**場所**: index.html:2568  
**概要**: エピソード詳細のHTMLテーブルを生成  

**引数**: `episodes` - エピソードデータの配列  
**戻り値**: HTMLテーブル文字列  

**動作**:
1. エピソードデータの存在チェック
2. HTMLテーブルのヘッダー生成（日付、曜日、楽曲数、告知数、予約数、パブ枠数）
3. 各エピソードのデータ行を生成
4. 完全なHTMLテーブル文字列を返却

### 4. toggleEpisodeDetails()
**場所**: index.html:2606  
**概要**: エピソード詳細の表示/非表示を切り替える  

**引数**: `index` - エピソードのインデックス  

**動作**:
1. 指定されたエピソードの詳細行要素を取得
2. 現在の表示状態をチェック
3. 表示状態を切り替え（none ↔ 空文字）
4. ボタンテキストを更新（表示 ↔ 非表示）

### 5. generateTransposeTable()
**場所**: src/99_main.ts:8871  
**概要**: 番組別詳細データを転置テーブル形式で生成するメイン関数  

**引数**:
- `programName` - 番組名（文字列）
- `weekType` - 週タイプ（'thisWeek', 'nextWeek', 'nextWeek2', 'nextWeek3'）

**戻り値**:
```typescript
{
  success: boolean,
  data?: TransposedTableData,
  error?: string,
  debugLogs: string[]
}
```

**動作**:
1. 入力パラメータの検証とサニタイズ
2. 週タイプから週番号への変換
3. 指定週のデータ取得（`extractWeekByNumber`）
4. 番組データの抽出（`extractProgramData`）
5. 転置テーブルデータ構造の生成（`generateTransposedTableData`）
6. 成功・エラー結果の返却
7. 全工程のデバッグログ記録

**エラーハンドリング**:
- パラメータ検証失敗
- データ取得失敗
- データ変換失敗
- 例外発生時のスタックトレース記録

### 6. displayEpisodeDetailsTable()
**場所**: src/99_main.ts:7149  
**概要**: エピソード詳細をコンソールに表形式で表示  

**引数**: `program` - 番組データオブジェクト  
**戻り値**: void  

**動作**:
1. エピソードデータの存在チェック
2. コンソール用テーブルヘッダーの出力
3. 各エピソードの集計データ計算
   - 楽曲数、ゲスト数、パブ枠数、アナウンス数、予約数
4. 固定幅フォーマットでテーブル行を出力
5. テーブルフッターの出力

### 7. generateTransposedTableData()
**場所**: src/99_main.ts:9019  
**概要**: 転置テーブル用のデータ構造を生成  

**引数**:
- `programData` - 番組の曜日別データ
- `programName` - 番組名

**戻り値**: 転置テーブル用データオブジェクトまたは null  

**動作**:
1. プログラムデータの基本検証
2. 曜日の順序付けとソート（月曜～日曜）
3. 各曜日の日付データ検証と取得
4. ヘッダー行の生成（"8/26月曜"形式）
5. 番組別項目の取得（`getProgramItems`）
6. 各項目の行データ生成
7. 最終データオブジェクトの構築

### 8. extractProgramData()
**場所**: src/99_main.ts:9141  
**概要**: 番組の曜日別データを転置テーブル用に変換  

**引数**:
- `programWeekData` - 週データオブジェクト
- `programName` - 番組名

**戻り値**: 曜日別プログラムデータオブジェクト  

**動作**:
1. 曜日マッピング定義（monday → 月曜）
2. 各曜日データの存在チェック
3. 指定番組のデータ抽出
4. 曜日別データオブジェクトの構築

### 9. convertToTransposedTable()
**場所**: src/99_main.ts:9171  
**概要**: 転置テーブルHTMLを生成  

**動作**:
1. 番組別項目定義の取得（`getProgramItems`）
2. 利用可能な曜日のソートと抽出
3. HTMLテーブルヘッダーの生成
4. 各項目行の生成（項目名を縦、日付を横に配置）
5. 項目データの取得と表示形式への変換
6. 完全なHTMLテーブル文字列の返却

## データ抽出の詳細フロー

番組別詳細表機能におけるデータ抽出は、複数の段階を経て行われる複雑なプロセスです。以下、各段階の詳細を説明します。

### 1. 週データの取得 (`extractWeekByNumber`)

**呼び出し元**: `generateTransposeTable()` → `extractWeekByNumber()`

**動作プロセス**:
- 週番号（1=今週、2=来週、3=来週の次、4=来週の次の次）を受け取る
- Google Sheets の設定から対象スプレッドシートにアクセス
- 週番号に対応するシート名を特定（例：24.8.26-9.1 形式）
- 全曜日データを含む週オブジェクトを返却

### 2. 番組データの抽出 (`extractProgramData`)

**場所**: src/99_main.ts:9141

#### 詳細な抽出プロセス:

**a) 曜日マッピングの定義**:
```typescript
const dayMapping = {
  'monday': '月曜',
  'tuesday': '火曜', 
  'wednesday': '水曜',
  'thursday': '木曜',
  'friday': '金曜',
  'saturday': '土曜',
  'sunday': '日曜'
};
```

**b) 曜日別データの走査と抽出**:
```typescript
for (const [englishDay, japaneseDay] of Object.entries(dayMapping)) {
  if (programWeekData[englishDay] && programWeekData[englishDay][programName]) {
    programData[japaneseDay] = programWeekData[englishDay][programName];
  }
}
```

**c) データ構造の変換**:
- **元データ**: `programWeekData.monday['ちょうどいいラジオ']`
- **変換後**: `programData['月曜']`

### 3. 転置テーブル用データ構造の生成 (`generateTransposedTableData`)

**場所**: src/99_main.ts:9019

#### a) 曜日の順序付けとソート
```typescript
const dayOrder = ['月曜', '火曜', '水曜', '木曜', '金曜', '土曜', '日曜'];
const availableDays = dayOrder.filter(day => programData[day]);
```

#### b) 各曜日の日付データ検証と取得
**詳細検証プロセス** (src/99_main.ts:9060-9078付近):
```typescript
for (const dayKey of availableDays) {
  const dayData = programData[dayKey];
  
  // 多段階検証
  console.log(`[DEBUG] ${dayKey}のデータ検証: exists=${!!dayData}, type=${typeof dayData}`);
  console.log(`[DEBUG] ${dayKey}の日付関連: hasDate=${dayData?.['日付'] ? true : false}`);
  
  // 安全な日付データアクセス
  if (dayData && dayData['日付'] && Array.isArray(dayData['日付']) && dayData['日付'].length > 0) {
    const dateStr = dayData['日付'][0]; // 配列の最初の要素
    const formattedHeader = formatDateWithDay(dateStr, japaneseDay);
    headers.push(formattedHeader); // "8/26月曜"形式でヘッダーに追加
  }
}
```

#### c) 番組項目データの抽出と変換
```typescript
// 番組別項目定義の取得
const programItems = getProgramItems(programName);

// 各項目のデータを日付別に抽出
programItems.forEach(item => {
  const rowData = [item]; // 項目名を行の最初に配置
  
  availableDays.forEach(day => {
    const dayData = programData[day];
    
    // 項目データの取得と変換
    if (dayData && dayData[item]) {
      const itemData = dayData[item];
      
      // データ形式に応じた処理
      if (Array.isArray(itemData)) {
        rowData.push(itemData.join(', ') || 'ー');
      } else {
        rowData.push(String(itemData) || 'ー');
      }
    } else {
      rowData.push('ー'); // データがない場合のデフォルト値
    }
  });
  
  rows.push(rowData);
});
```

## データ構造の詳細

### 入力データ構造例
Google Sheets から取得される生データの構造：

```json
{
  "monday": {
    "ちょうどいいラジオ": {
      "日付": ["2024/8/26"],
      "楽曲": ["楽曲A", "楽曲B"],
      "ゲスト": ["ゲスト名"],
      "7:28パブ告知": ["告知内容"],
      "時間指定なし告知": ["告知内容2"],
      "YOKOHAMA PORTSIDE INFORMATION": [],
      "指定曲": ["指定楽曲"],
      "先行予約": ["イベント予約"],
      "6:45ラジオショッピング": ["商品A"],
      "8:29はぴねすくらぶ": [],
      "収録予定": ["収録情報"]
    }
  },
  "tuesday": {
    "ちょうどいいラジオ": {
      "日付": ["2024/8/27"],
      "楽曲": ["楽曲C"],
      "ゲスト": [],
      // ... その他項目
    }
  }
  // ... 他曜日
}
```

### 抽出後のデータ構造
転置テーブル表示用に変換されたデータ構造：

```json
{
  "programName": "ちょうどいいラジオ",
  "headers": ["項目", "8/26月曜", "8/27火曜", "8/28水曜", "8/29木曜"],
  "rows": [
    ["7:28パブ告知", "告知内容", "ー", "告知内容3", "ー"],
    ["時間指定なし告知", "告知内容2", "告知内容4", "ー", "告知内容5"],
    ["YOKOHAMA PORTSIDE INFORMATION", "ー", "情報A", "ー", "情報B"],
    ["楽曲", "楽曲A, 楽曲B", "楽曲C", "楽曲D, 楽曲E", "楽曲F"],
    ["ゲスト", "ゲスト名", "ー", "ゲスト名2", "ー"],
    ["指定曲", "指定楽曲", "ー", "指定楽曲2", "ー"],
    ["先行予約", "イベント予約", "ー", "ー", "イベント予約2"],
    ["6:45ラジオショッピング", "商品A", "商品B", "ー", "商品C"],
    ["8:29はぴねすくらぶ", "ー", "ー", "内容A", "ー"],
    ["収録予定", "収録情報", "ー", "収録情報2", "収録情報3"]
  ]
}
```

### データ変換の流れ
1. **縦横変換**: 日付×項目 → 項目×日付
2. **配列の文字列化**: `["楽曲A", "楽曲B"]` → `"楽曲A, 楽曲B"`
3. **空データの統一**: `null`, `undefined`, `[]` → `"ー"`
4. **ヘッダーのフォーマット**: `"2024/8/26"` + `"月曜"` → `"8/26月曜"`

## 番組別項目定義の詳細

### `getProgramItems()` 関数の仕様

**場所**: src/99_main.ts内（具体的な行番号は調査で特定）

**動作**: 番組名を受け取り、その番組に特化した表示項目のリストを返却

### 各番組の具体的な項目リスト

#### ちょうどいいラジオ
**各日の項目**:
- 7:28パブ告知
- 時間指定なし告知  
- YOKOHAMA PORTSIDE INFORMATION
- 指定曲
- 先行予約
- ゲスト
- 6:45ラジオショッピング
- 8:29はぴねすくらぶ
- 収録予定

**週間項目**:
- ちょうどいい暮らし
- ここが知りたい不動産
- ちょうどいい歯ッピー
- ちょうどいいおカネの話
- ちょうどいいごりごり隊
- ちょうどいい a Life
- ビジネスアイ

#### PRIME TIME
- 19:43パブリシティ
- 20:51パブリシティ
- 営業コーナー
- 指定曲
- ゲスト
- 時間指定なしパブ
- ラジショピ
- 先行予約

#### FLAG
- 12:40電話パブ
- 13:29パブリシティ
- 13:40パブリシティ
- 12:15リポート案件
- 14:29リポート案件
- 時間指定なし告知
- 楽曲
- 先行予約
- 収録予定

#### その他番組
**God Bless Saturday**: キリンパークシティーヨコハマ、指定曲、14:41パブ、時間指定なし告知  
**Route 847**: 16:47パブ、17:41パブ、時間指定なし告知、指定曲

### 改善点.txtとの関連性
項目定義は `/改善点.txt` の「番組詳細データ表示について」セクションの要件に基づいて実装されています。各番組の特性に応じた項目カスタマイゼーションが可能な柔軟な設計となっています。

## デバッグログとエラーハンドリングの詳細

### データ検証の各レイヤー

#### 1. 週データレベルの検証
```typescript
if (!weekResults || Object.keys(weekResults).length === 0) {
  log('[ERROR] 週データが見つかりません');
  return {success: false, error: '指定週のデータが存在しません'};
}
```

#### 2. 番組データレベルの検証  
```typescript
const programData = extractProgramData(weekResults, programName);
if (!programData || Object.keys(programData).length === 0) {
  log('[ERROR] 番組データが見つかりません');
  return {success: false, error: '指定番組のデータが存在しません'};
}
```

#### 3. 曜日データレベルの検証
```typescript
console.log(`[DEBUG] ${dayKey}のデータ検証: exists=${!!dayData}, type=${typeof dayData}`);
console.log(`[DEBUG] ${dayKey}の日付関連: hasDate=${dayData?.['日付'] ? true : false}`);
console.log(`[DEBUG] ${dayKey}の完全なデータ内容:`, JSON.stringify(dayData, null, 2));
```

#### 4. 項目データレベルの検証
各項目データの形式検証とデフォルト値設定が行われます。

### デバッグログの具体例

**成功ケースのログ**:
```
[DEBUG] 転置テーブル生成開始: ちょうどいいラジオ, 週タイプ: thisWeek
[DEBUG] 週番号: 1 (thisWeek)
[DEBUG] extractWeekByNumber(1)を呼び出し中...
[DEBUG] 取得されたキー: [monday, tuesday, wednesday, thursday]
[DEBUG] 番組データ抽出完了: 4曜日のデータを取得
[DEBUG] 月曜のデータ検証: exists=true, type=object
[DEBUG] 月曜の日付関連: hasDate=true
[DEBUG] 転置テーブル生成完了: ちょうどいいラジオ
```

**エラーケースのログ**:
```
[ERROR] 週データが見つかりません
[ERROR] weekResultsの値: {}
[DEBUG] extractWeekByNumberの結果: object, キー数: 0
[ERROR] 転置テーブルデータの生成に失敗しました
```

### エラー追跡の方法

1. **段階的ログ追跡**: 各処理段階でのデバッグ情報記録
2. **スタックトレース保存**: 例外発生時の詳細情報保存  
3. **フロントエンド表示**: デバッグログをWebUI上で確認可能
4. **データ構造の詳細出力**: 問題のあるデータの完全な構造を JSON形式で出力

## ヘルパー関数

### mapWeekTypeToNumber()
**場所**: src/99_main.ts:8860  
**概要**: 週タイプ文字列を番号に変換  
**マッピング**:
- 'thisWeek' → 1
- 'nextWeek' → 2  
- 'nextWeek2' → 3
- 'nextWeek3' → 4

### formatDateWithDay()
**場所**: src/99_main.ts:8993  
**概要**: 日付文字列と曜日を組み合わせたヘッダー形式にフォーマット  
**例**: "2024/8/26" + "月曜" → "8/26月曜"

### getDateForDay()
**場所**: src/99_main.ts:9461  
**概要**: 曜日名から対応する日付を取得（シートアクセス方式）

## 楽曲データベース連携機能

番組別詳細表では、楽曲情報の正確な取得と表示のために包括的な楽曲データベース連携システムが実装されています。

### 楽曲処理の全体フロー

```
1. 番組表データ → splitMusicData() で分割
2. ♪マークで分割 → 個別楽曲テキスト抽出
3. processMusicText() → cleanMusicText() でクリーニング
4. searchMusicData() → 5段階検索アルゴリズム実行
5. データベースヒット → 詳細情報付加
6. 最終楽曲オブジェクト生成 → 表示用フォーマット適用
```

### 主要関数の詳細

#### 1. getMusicData() - 楽曲データベース読み込み

**場所**: src/99_main.ts:3914-3955  
**概要**: 専用の楽曲データベーススプレッドシートから楽曲データを読み込む基幹関数  

**動作プロセス**:

**a) 設定とスプレッドシートアクセス**:
```typescript
const config = getConfig();
const musicSpreadsheet = SpreadsheetApp.openById(config.MUSIC_SPREADSHEET_ID);
const musicSheet = musicSpreadsheet.getSheetByName(config.MUSIC_SHEET_NAME);
```

**b) 必要な列の自動検出**:
```typescript
const songTitleColIndex = findColumnIndex(headers, ['曲名', 'タイトル', 'title', 'song']);
const artistColIndex = findColumnIndex(headers, ['アーティスト', 'artist', 'singer']);
const urlColIndex = findColumnIndex(headers, ['URL', 'url', '音源', '音源データ', 'link']);
```
- 複数の候補名で列を検索（日英対応）
- 柔軟なスプレッドシート構造に対応

**c) データオブジェクトの生成**:
```typescript
return data.slice(1).map(row => ({
  title: row[songTitleColIndex] ? row[songTitleColIndex].toString().trim() : '',
  artist: row[artistColIndex] ? row[artistColIndex].toString().trim() : '',
  url: urlColIndex >= 0 && row[urlColIndex] ? row[urlColIndex].toString().trim() : ''
})).filter(song => song.title || song.artist);
```

**エラーハンドリング**:
- シート存在チェック
- 必要列の存在確認  
- 空データチェック
- 例外処理でエラーログ出力

#### 2. searchMusicData() - 高精度楽曲検索

**場所**: src/99_main.ts:4152-4240  
**概要**: 番組表のテキストから楽曲データベースを検索してマッチする楽曲情報を取得

**5段階の高度検索アルゴリズム**:

**第1段階: 曲名での前方一致検索**:
```typescript
let match = musicDatabase.find(song => 
  song.title && song.title.toLowerCase().includes(cleanedSearchText)
);
```

**第2段階: アーティスト名での前方一致検索**:
```typescript
match = musicDatabase.find(song => 
  song.artist && song.artist.toLowerCase().includes(cleanedSearchText)
);
```

**第3段階: 逆検索（曲名）**:
```typescript
match = musicDatabase.find(song => 
  song.title && cleanedSearchText.includes(song.title.toLowerCase())
);
```

**第4段階: 逆検索（アーティスト名）**:
```typescript
match = musicDatabase.find(song => 
  song.artist && cleanedSearchText.includes(song.artist.toLowerCase())
);
```

**第5段階: 部分検索（複数単語対応）**:
```typescript
const words = cleanedSearchText.split(/\s+/);
match = musicDatabase.find(song => {
  const songText = `${song.title} ${song.artist}`.toLowerCase();
  return words.some(word => songText.includes(word) && word.length > 1);
});
```

**データクリーニング機能**:
- 検索結果から「楽曲DB登録済み:」等の付帯情報を除去
- 統一フォーマットでの返却

#### 3. splitMusicData() - 楽曲データ分割・拡張

**場所**: src/99_main.ts:4246-4309  
**概要**: 番組表の楽曲データを個別楽曲に分割し、データベース検索で情報を拡張

**処理フロー**:

**a) 入力データ検証**:
```typescript
if (!content || !Array.isArray(content)) {
  return [{ 曲名: 'ー', URL: '' }];
}
if (!musicDatabase) {
  return [{ 曲名: 'ー', URL: '' }];
}
```

**b) オブジェクト型データの処理**:
```typescript
if (typeof item === 'object' && item !== null) {
  if (item.曲名 || item.URL) {
    const cleanedItem = cleanMusicObject(item);
    musicList.push(cleanedItem);
  }
}
```

**c) 文字列型データの分割処理**:
```typescript
if (typeof item === 'string' && item.includes('♪')) {
  const parts = item.split('♪');
  // ♪マークで分割して個別楽曲を抽出
}
```

**d) 楽曲テキスト処理**:
- `processMusicText()`を呼び出して各楽曲を処理
- データベース検索で情報を拡張

#### 4. processMusicText() - 楽曲テキスト処理・情報付加

**場所**: src/99_main.ts:4314-4337  
**概要**: 単一楽曲テキストを処理し、データベース検索で詳細情報を付加

**処理ステップ**:

**a) テキストクリーニング**:
```typescript
const cleanedText = cleanMusicText(text);
```

**b) データベース検索**:
```typescript
const musicData = searchMusicData(musicDatabase, cleanedText);
```

**c) 検索成功時の処理**:
```typescript
if (musicData && musicData.title && musicData.artist) {
  const cleanTitle = musicData.title.replace(/\s*楽曲DB登録済み:.*$/g, '').trim();
  const cleanArtist = musicData.artist.replace(/\s*楽曲DB登録済み:.*$/g, '').trim();
  const songTitle = `♪${cleanTitle}／${cleanArtist} ※マストコメント`;
  
  return {
    曲名: songTitle,
    URL: musicData.url || ''
  };
}
```

**d) 検索失敗時の処理**:
```typescript
return {
  曲名: `${cleanedText} ※マストコメント`,
  URL: ''
};
```

### 補助関数

#### cleanMusicText() - 楽曲テキスト正規化
**場所**: src/99_main.ts:4377-4386  
**概要**: 楽曲テキストから検索の邪魔になる文字を除去

**除去対象**:
- 数字（0-9、０-９）
- 番号記号（①②③...⑳、⑴⑵⑶...⒇、㈠㈡㈢...㈩）
- 特殊文字、空白

#### cleanMusicObject() - 楽曲オブジェクト清浄化
**場所**: src/99_main.ts:4391-4412  
**概要**: 楽曲オブジェクトから付帯情報を完全に除去

**処理内容**:
- 付帯情報フィールドの完全除去
- 必要フィールド（曲名、URL）のみ保持
- 「※マストコメント」の自動付加

### 楽曲フォーマット機能

番組表生成時には以下の複数フォーマットに対応:

- **formatMusicList()**: 番号付きリスト形式
- **formatMusicListSimple()**: 番号なしシンプル形式
- **formatMusicListBullet()**: 箇条書き形式
- **formatMusicListTable()**: テーブル形式
- **formatMusicListOneLine()**: 1行ずつ形式

### 設定項目

楽曲データベース連携に必要な設定:

- **MUSIC_SPREADSHEET_ID**: 楽曲データベーススプレッドシートのID
- **MUSIC_SHEET_NAME**: 楽曲データを格納するシート名

### 楽曲データの統合例

**入力データ例**:
```
["♪楽曲A", "♪楽曲B／アーティストB", "指定曲: 楽曲C"]
```

**処理後のデータ例**:
```json
[
  {
    "曲名": "♪楽曲A／データベースアーティストA ※マストコメント",
    "URL": "https://example.com/track-a"
  },
  {
    "曲名": "♪楽曲B／アーティストB ※マストコメント", 
    "URL": ""
  },
  {
    "曲名": "♪楽曲C／データベースアーティストC ※マストコメント",
    "URL": "https://example.com/track-c"
  }
]
```

この楽曲データベース連携システムにより、番組別詳細表では正確で詳細な楽曲情報を自動的に取得・表示できます。

## エラーハンドリング方針

### フロントエンド
- ユーザー入力の厳密な検証
- APIエラーの適切な表示
- デバッグログによる詳細情報提供
- ユーザーフレンドリーなエラーメッセージ

### バックエンド
- 段階的なデータ検証
- 詳細なデバッグログ記録
- 例外の適切なキャッチとログ出力
- スタックトレースの保存

## 特殊な設計パターン

### 転置テーブル
項目を縦軸、日付を横軸とする表形式で、従来の日付縦・項目横とは逆の配置を採用。これにより、多数の項目を持つ番組でも横スクロールを抑制し、見やすさを向上。

### デバッグログ機能
開発・保守時のトラブルシューティングを支援するため、全関数でデバッグログを記録し、フロントエンドで表示可能。

### 番組別項目定義
`getProgramItems()`関数により、番組ごとに表示項目をカスタマイズ可能な設計。改善点.txtの要件に基づく柔軟な項目管理を実現。

## 関連ファイル
- **改善点.txt**: 番組別詳細表の要件定義
- **index.html**: フロントエンド実装
- **src/99_main.ts**: バックエンド実装
- **.clasp.json**: Google Apps Script プロジェクト設定